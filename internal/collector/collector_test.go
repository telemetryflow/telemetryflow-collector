// Package collector provides the core collector lifecycle management.
//
// TelemetryFlow Collector - Community Enterprise Observability Platform (CEOP)
// Copyright (c) 2024-2026 TelemetryFlow. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package collector

import (
	"context"
	"fmt"
	"net"
	"net/http"
	"testing"
	"time"

	"go.uber.org/zap"
	"go.uber.org/zap/zaptest"

	"github.com/telemetryflow/telemetryflow-collector/internal/config"
)

// Helper function to get a free port
func getFreePort() (int, error) {
	addr, err := net.ResolveTCPAddr("tcp", "localhost:0")
	if err != nil {
		return 0, err
	}

	l, err := net.ListenTCP("tcp", addr)
	if err != nil {
		return 0, err
	}
	defer func() { _ = l.Close() }()
	return l.Addr().(*net.TCPAddr).Port, nil
}

// createTestConfig creates a test configuration with free ports
func createTestConfig(t *testing.T) *config.Config {
	grpcPort, err := getFreePort()
	if err != nil {
		t.Fatalf("Failed to get free port: %v", err)
	}

	httpPort, err := getFreePort()
	if err != nil {
		t.Fatalf("Failed to get free port: %v", err)
	}

	healthPort, err := getFreePort()
	if err != nil {
		t.Fatalf("Failed to get free port: %v", err)
	}

	cfg := config.DefaultConfig()
	cfg.Collector.ID = "test-collector"
	cfg.Collector.Hostname = "test-host"
	cfg.Collector.Name = "Test Collector"

	cfg.Receivers.OTLP.Enabled = true
	cfg.Receivers.OTLP.Protocols.GRPC.Enabled = true
	cfg.Receivers.OTLP.Protocols.GRPC.Endpoint = fmt.Sprintf("localhost:%d", grpcPort)
	cfg.Receivers.OTLP.Protocols.HTTP.Enabled = true
	cfg.Receivers.OTLP.Protocols.HTTP.Endpoint = fmt.Sprintf("localhost:%d", httpPort)

	cfg.Extensions.Health.Enabled = true
	cfg.Extensions.Health.Endpoint = fmt.Sprintf("localhost:%d", healthPort)
	cfg.Extensions.Health.Path = "/health"

	cfg.Exporters.Debug.Verbosity = "basic"

	return cfg
}

// createMinimalConfig creates a minimal test configuration
func createMinimalConfig(t *testing.T) *config.Config {
	cfg := config.DefaultConfig()
	cfg.Collector.ID = "minimal-collector"
	cfg.Collector.Hostname = "minimal-host"

	cfg.Receivers.OTLP.Enabled = false
	cfg.Receivers.Prometheus.Enabled = false
	cfg.Extensions.Health.Enabled = false
	cfg.Exporters.Debug.Verbosity = ""

	return cfg
}

// TestNew tests collector creation
func TestNew(t *testing.T) {
	tests := []struct {
		name        string
		setupConfig func(t *testing.T) *config.Config
		wantErr     bool
	}{
		{
			name: "full config",
			setupConfig: func(t *testing.T) *config.Config {
				return createTestConfig(t)
			},
			wantErr: false,
		},
		{
			name: "minimal config",
			setupConfig: func(t *testing.T) *config.Config {
				return createMinimalConfig(t)
			},
			wantErr: false,
		},
		{
			name: "with auto-generated ID",
			setupConfig: func(t *testing.T) *config.Config {
				cfg := createMinimalConfig(t)
				cfg.Collector.ID = "" // Should be auto-generated
				return cfg
			},
			wantErr: false,
		},
		{
			name: "with debug exporter enabled",
			setupConfig: func(t *testing.T) *config.Config {
				cfg := createMinimalConfig(t)
				cfg.Exporters.Debug.Verbosity = "detailed"
				return cfg
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			logger := zaptest.NewLogger(t)
			cfg := tt.setupConfig(t)

			c, err := New(cfg, logger)

			if tt.wantErr {
				if err == nil {
					t.Error("Expected error, got nil")
				}
				return
			}

			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			if c == nil {
				t.Fatal("Expected non-nil collector")
			}

			// Verify ID is set
			if c.ID() == "" {
				t.Error("Expected non-empty ID")
			}
		})
	}
}

// TestID tests the ID method
func TestID(t *testing.T) {
	logger := zaptest.NewLogger(t)
	cfg := createMinimalConfig(t)
	cfg.Collector.ID = "test-id-12345"

	c, err := New(cfg, logger)
	if err != nil {
		t.Fatalf("Failed to create collector: %v", err)
	}

	if c.ID() != "test-id-12345" {
		t.Errorf("Expected ID 'test-id-12345', got '%s'", c.ID())
	}
}

// TestIDAutoGenerated tests auto-generated ID
func TestIDAutoGenerated(t *testing.T) {
	logger := zaptest.NewLogger(t)
	cfg := createMinimalConfig(t)
	cfg.Collector.ID = ""

	c, err := New(cfg, logger)
	if err != nil {
		t.Fatalf("Failed to create collector: %v", err)
	}

	if c.ID() == "" {
		t.Error("Expected auto-generated ID, got empty string")
	}

	// UUID format check
	if len(c.ID()) != 36 {
		t.Errorf("Expected UUID format (36 chars), got %d chars", len(c.ID()))
	}
}

// TestIsRunning tests the IsRunning method
func TestIsRunning(t *testing.T) {
	logger := zaptest.NewLogger(t)
	cfg := createMinimalConfig(t)

	c, err := New(cfg, logger)
	if err != nil {
		t.Fatalf("Failed to create collector: %v", err)
	}

	// Should not be running initially
	if c.IsRunning() {
		t.Error("Expected IsRunning to be false initially")
	}
}

// TestUptime tests the Uptime method
func TestUptime(t *testing.T) {
	logger := zaptest.NewLogger(t)
	cfg := createMinimalConfig(t)

	c, err := New(cfg, logger)
	if err != nil {
		t.Fatalf("Failed to create collector: %v", err)
	}

	// Should return 0 when not running
	if c.Uptime() != 0 {
		t.Errorf("Expected uptime 0 when not running, got %v", c.Uptime())
	}
}

// TestStats tests the Stats method
func TestStats(t *testing.T) {
	logger := zaptest.NewLogger(t)
	cfg := createMinimalConfig(t)
	cfg.Collector.Hostname = "stats-test-host"

	c, err := New(cfg, logger)
	if err != nil {
		t.Fatalf("Failed to create collector: %v", err)
	}

	stats := c.Stats()

	if stats.ID != c.ID() {
		t.Errorf("Expected ID '%s', got '%s'", c.ID(), stats.ID)
	}

	if stats.Hostname != "stats-test-host" {
		t.Errorf("Expected hostname 'stats-test-host', got '%s'", stats.Hostname)
	}

	if stats.Running {
		t.Error("Expected Running to be false")
	}
}

// TestRunAndShutdown tests collector run and shutdown
func TestRunAndShutdown(t *testing.T) {
	logger := zaptest.NewLogger(t)
	cfg := createTestConfig(t)

	c, err := New(cfg, logger)
	if err != nil {
		t.Fatalf("Failed to create collector: %v", err)
	}

	ctx, cancel := context.WithCancel(context.Background())

	// Start collector in goroutine
	errCh := make(chan error, 1)
	go func() {
		errCh <- c.Run(ctx)
	}()

	// Wait for collector to start
	time.Sleep(100 * time.Millisecond)

	// Verify collector is running
	if !c.IsRunning() {
		t.Error("Expected collector to be running")
	}

	// Verify uptime is positive
	if c.Uptime() <= 0 {
		t.Error("Expected positive uptime")
	}

	// Trigger shutdown
	cancel()

	// Wait for shutdown
	select {
	case err := <-errCh:
		if err != nil {
			t.Errorf("Unexpected error from Run: %v", err)
		}
	case <-time.After(5 * time.Second):
		t.Error("Timeout waiting for collector to stop")
	}

	// Verify collector is no longer running
	if c.IsRunning() {
		t.Error("Expected collector to not be running after shutdown")
	}
}

// TestRunAlreadyRunning tests that starting an already running collector fails
func TestRunAlreadyRunning(t *testing.T) {
	logger := zaptest.NewLogger(t)
	cfg := createTestConfig(t)

	c, err := New(cfg, logger)
	if err != nil {
		t.Fatalf("Failed to create collector: %v", err)
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Start collector in goroutine
	go func() {
		_ = c.Run(ctx)
	}()

	// Wait for collector to start
	time.Sleep(100 * time.Millisecond)

	// Try to start again
	err = c.Run(context.Background())
	if err == nil {
		t.Error("Expected error when starting already running collector")
	}
}

// TestHealthServer tests the health check server
func TestHealthServer(t *testing.T) {
	logger := zaptest.NewLogger(t)
	cfg := createTestConfig(t)

	c, err := New(cfg, logger)
	if err != nil {
		t.Fatalf("Failed to create collector: %v", err)
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Start collector
	go func() {
		_ = c.Run(ctx)
	}()

	// Wait for collector to start
	time.Sleep(200 * time.Millisecond)

	// Check health endpoint
	healthURL := fmt.Sprintf("http://%s%s", cfg.Extensions.Health.Endpoint, cfg.Extensions.Health.Path)
	resp, err := http.Get(healthURL)
	if err != nil {
		t.Fatalf("Failed to check health endpoint: %v", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		t.Errorf("Expected status 200, got %d", resp.StatusCode)
	}

	// Check stats endpoint
	statsURL := fmt.Sprintf("http://%s/stats", cfg.Extensions.Health.Endpoint)
	resp, err = http.Get(statsURL)
	if err != nil {
		t.Fatalf("Failed to check stats endpoint: %v", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		t.Errorf("Expected status 200 for stats, got %d", resp.StatusCode)
	}
}

// TestCollectorStatsStruct tests CollectorStats struct
func TestCollectorStatsStruct(t *testing.T) {
	now := time.Now()
	stats := CollectorStats{
		ID:       "test-id",
		Hostname: "test-host",
		Running:  true,
		Started:  now,
		Uptime:   5 * time.Minute,
		ReceiverStats: ReceiverStats{
			TracesReceived:  100,
			MetricsReceived: 200,
			LogsReceived:    300,
		},
		PipelineStats: PipelineStats{
			TracesProcessed:  90,
			MetricsProcessed: 190,
			LogsProcessed:    290,
		},
	}

	if stats.ID != "test-id" {
		t.Errorf("Expected ID 'test-id', got '%s'", stats.ID)
	}
	if stats.Hostname != "test-host" {
		t.Errorf("Expected Hostname 'test-host', got '%s'", stats.Hostname)
	}
	if !stats.Running {
		t.Error("Expected Running to be true")
	}
	if stats.Started != now {
		t.Errorf("Expected Started %v, got %v", now, stats.Started)
	}
	if stats.Uptime != 5*time.Minute {
		t.Errorf("Expected Uptime 5m, got %v", stats.Uptime)
	}
	if stats.ReceiverStats.TracesReceived != 100 {
		t.Errorf("Expected TracesReceived 100, got %d", stats.ReceiverStats.TracesReceived)
	}
	if stats.ReceiverStats.MetricsReceived != 200 {
		t.Errorf("Expected MetricsReceived 200, got %d", stats.ReceiverStats.MetricsReceived)
	}
	if stats.ReceiverStats.LogsReceived != 300 {
		t.Errorf("Expected LogsReceived 300, got %d", stats.ReceiverStats.LogsReceived)
	}
	if stats.PipelineStats.TracesProcessed != 90 {
		t.Errorf("Expected TracesProcessed 90, got %d", stats.PipelineStats.TracesProcessed)
	}
	if stats.PipelineStats.MetricsProcessed != 190 {
		t.Errorf("Expected MetricsProcessed 190, got %d", stats.PipelineStats.MetricsProcessed)
	}
	if stats.PipelineStats.LogsProcessed != 290 {
		t.Errorf("Expected LogsProcessed 290, got %d", stats.PipelineStats.LogsProcessed)
	}
}

// TestReceiverStatsStruct tests ReceiverStats struct
func TestReceiverStatsStruct(t *testing.T) {
	stats := ReceiverStats{
		TracesReceived:  1000,
		MetricsReceived: 2000,
		LogsReceived:    3000,
	}

	if stats.TracesReceived != 1000 {
		t.Errorf("Expected TracesReceived 1000, got %d", stats.TracesReceived)
	}
	if stats.MetricsReceived != 2000 {
		t.Errorf("Expected MetricsReceived 2000, got %d", stats.MetricsReceived)
	}
	if stats.LogsReceived != 3000 {
		t.Errorf("Expected LogsReceived 3000, got %d", stats.LogsReceived)
	}
}

// TestPipelineStatsStruct tests PipelineStats struct
func TestPipelineStatsStruct(t *testing.T) {
	stats := PipelineStats{
		TracesProcessed:  900,
		MetricsProcessed: 1900,
		LogsProcessed:    2900,
	}

	if stats.TracesProcessed != 900 {
		t.Errorf("Expected TracesProcessed 900, got %d", stats.TracesProcessed)
	}
	if stats.MetricsProcessed != 1900 {
		t.Errorf("Expected MetricsProcessed 1900, got %d", stats.MetricsProcessed)
	}
	if stats.LogsProcessed != 2900 {
		t.Errorf("Expected LogsProcessed 2900, got %d", stats.LogsProcessed)
	}
}

// TestCollectorWithDebugExporter tests collector with debug exporter enabled
func TestCollectorWithDebugExporter(t *testing.T) {
	logger := zaptest.NewLogger(t)
	cfg := createMinimalConfig(t)
	cfg.Exporters.Debug.Verbosity = "detailed"

	c, err := New(cfg, logger)
	if err != nil {
		t.Fatalf("Failed to create collector: %v", err)
	}

	if c.debugExporter == nil {
		t.Error("Expected debug exporter to be initialized")
	}

	if c.pipeline == nil {
		t.Error("Expected pipeline to be initialized")
	}
}

// TestCollectorWithoutDebugExporter tests collector without debug exporter
func TestCollectorWithoutDebugExporter(t *testing.T) {
	logger := zaptest.NewLogger(t)
	cfg := createMinimalConfig(t)
	cfg.Exporters.Debug.Verbosity = ""

	c, err := New(cfg, logger)
	if err != nil {
		t.Fatalf("Failed to create collector: %v", err)
	}

	if c.debugExporter != nil {
		t.Error("Expected debug exporter to be nil when not enabled")
	}
}

// TestCollectorWithOTLPReceiver tests collector with OTLP receiver
func TestCollectorWithOTLPReceiver(t *testing.T) {
	logger := zaptest.NewLogger(t)
	cfg := createTestConfig(t)

	c, err := New(cfg, logger)
	if err != nil {
		t.Fatalf("Failed to create collector: %v", err)
	}

	if c.otlpReceiver == nil {
		t.Error("Expected OTLP receiver to be initialized")
	}
}

// TestCollectorWithoutOTLPReceiver tests collector without OTLP receiver
func TestCollectorWithoutOTLPReceiver(t *testing.T) {
	logger := zaptest.NewLogger(t)
	cfg := createMinimalConfig(t)
	cfg.Receivers.OTLP.Enabled = false

	c, err := New(cfg, logger)
	if err != nil {
		t.Fatalf("Failed to create collector: %v", err)
	}

	if c.otlpReceiver != nil {
		t.Error("Expected OTLP receiver to be nil when not enabled")
	}
}

// TestStatsWhileRunning tests stats while collector is running
func TestStatsWhileRunning(t *testing.T) {
	logger := zaptest.NewLogger(t)
	cfg := createTestConfig(t)

	c, err := New(cfg, logger)
	if err != nil {
		t.Fatalf("Failed to create collector: %v", err)
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Start collector
	go func() {
		_ = c.Run(ctx)
	}()

	// Wait for collector to start
	time.Sleep(100 * time.Millisecond)

	stats := c.Stats()

	if !stats.Running {
		t.Error("Expected Running to be true while collector is running")
	}

	if stats.ID != c.ID() {
		t.Errorf("Expected ID '%s', got '%s'", c.ID(), stats.ID)
	}

	if stats.Uptime <= 0 {
		t.Error("Expected positive uptime while running")
	}
}

// TestConcurrentStatsAccess tests concurrent access to Stats
func TestConcurrentStatsAccess(t *testing.T) {
	logger := zap.NewNop()
	cfg := createMinimalConfig(t)

	c, err := New(cfg, logger)
	if err != nil {
		t.Fatalf("Failed to create collector: %v", err)
	}

	// Run multiple goroutines accessing Stats concurrently
	done := make(chan bool)
	for i := 0; i < 10; i++ {
		go func() {
			for j := 0; j < 100; j++ {
				_ = c.Stats()
				_ = c.IsRunning()
				_ = c.Uptime()
			}
			done <- true
		}()
	}

	// Wait for all goroutines to complete
	for i := 0; i < 10; i++ {
		<-done
	}
}

// Benchmark tests
func BenchmarkNew(b *testing.B) {
	logger := zap.NewNop()
	cfg := config.DefaultConfig()
	cfg.Receivers.OTLP.Enabled = false
	cfg.Extensions.Health.Enabled = false

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = New(cfg, logger)
	}
}

func BenchmarkStats(b *testing.B) {
	logger := zap.NewNop()
	cfg := config.DefaultConfig()
	cfg.Receivers.OTLP.Enabled = false
	cfg.Extensions.Health.Enabled = false

	c, _ := New(cfg, logger)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = c.Stats()
	}
}

func BenchmarkIsRunning(b *testing.B) {
	logger := zap.NewNop()
	cfg := config.DefaultConfig()
	cfg.Receivers.OTLP.Enabled = false
	cfg.Extensions.Health.Enabled = false

	c, _ := New(cfg, logger)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = c.IsRunning()
	}
}
